void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*))
参数
base-- 指向要排序的数组的第一个元素的指针。
nitems-- 由 base 指向的数组中元素的个数。
size-- 数组中每个元素的大小，以字节为单位。
compar-- 用来比较两个元素的函数，即函数指针（回调函数）

1.int 型qsort

 int compare(const void *a, const void *b)
{
	return *(int *)a- *(int *)b;
}
int main()
{
	int i = 0; int n = 0;
	int *arr;
	scanf("%d",&n);
	arr = (int *)malloc(sizeof(int)*n);//给arr指针指向的地方开辟空间
	for(i=0;i<n;i++)
	{
		scanf("%d",&arr[i]);
	}
	qsort(arr, n, sizeof(int), compare);

	for (i = 0; i<n; i++)
	{
		printf("%d ", arr[i]);

	}
	return 0;
}
2.对字符串qsort排序
char compare(const void *a, const void *b)
{
	return strcmp((char*)a, (char*)b);
}
int main()
{
	int n =0,i= 0;
	
	char *arr;
	arr = (char *)malloc(n);
	scanf("%s", arr);
	int len = strlen(arr);
	qsort(arr, len,1, compare);
	printf("%s",arr);
}
给二位动态数组怎么排序每行排序

int compare(const void *a, const void *b)
{
	return (*(int *)a - *(int *)b);
}
int main()
{
	int m = 0, n = 0; 
	scanf("%d%d", &m, &n);
	int **arr;   //指向二维数组的指针
	arr = (int **)malloc(sizeof(int *)*m);
	for (int i=0; i < m; i++)
	{
		arr[i] = (int *)malloc(sizeof(int)*n);//给每一行开辟 n个空间
	}
	for (int i=0; i < m; i++)
	{
		for (int j=0; j < n; j++)
		{
			scanf("%d", &arr[i][j]);
		}
	}
	for (int i = 0; i < m; i++)
	{

		qsort(arr[i], n, sizeof(arr[0][0]), compare);
	}
	
	for (int i=0; i < m; i++)
	{
		for (int j=0; j < n; j++)
		{
			printf("%d ", arr[i][j]);
		}printf("\n");
	}

}

3.非动态二维数组全部排序
int compare(const void* a, const void* b)
{
	return (*((int*)a)- (*(int*)b));
}

int main()
{
	int i = 0, j = 0;

	
	int arr[3][3] = { { 5, 6, 7 }, { 77,10,3 }, { 2, 50, 0 } };
	

		qsort(arr, 9, sizeof(arr[0][0]), compare);
	

	for (i = 0; i < 3; i++)
	{
		for (j = 0; j < 3; j++)
		{
			printf("%d ", arr[i][j]);
		}
		printf("\n");
	}

	return 0;
}
4.不改变每一行元素的顺序，按每一行第一个元素排序
int compare(const void* a, const void* b)
{
	return (((int*)a)[0] - ((int*)b)[0]);
}

int main()
{
	int i = 0, j = 0;


	int arr[3][3] = { { 7, 6, 1 }, { 77,10,3 }, { 2, 50, 0 } };



		qsort(arr, 3, sizeof(arr[0]), compare);
	

	for (i = 0; i < 3; i++)
	{
		for (j = 0; j < 3; j++)
		{
			printf("%d ", arr[i][j]);
		}
		printf("\n");
	}

	return 0;
}

qsort的模拟实现用冒泡排序

int compar(const void *a, const void *b)
{
	return (*(int *)a>*(int *)b);
}

void swap( void *a,  void *b,int size)//以字节为单位进行交换
{
	int i = 0;
	for (i = 0; i < size; i++)
	{
		
			char c =*((char *)a + i);
			*((char *)a + i )= *((char *)b + i);
			*((char *)b + i) = c;

	}
	
}
void  my_qsort(void *base, size_t nitems, size_t size, int(*compar)(const void *, const void*))
{
	for (int i = 0; i <( nitems - 1); i++)
	{
		for (int j = 0; j < (nitems - i - 1); j++)
		{
			if (compar((char *)base + j*size, (char *)base + (j + 1)*size)>0)
			{
				swap((char *)base + j*size, (char *)base + (j + 1)*size, size);
			}
		}
	}
}
int main()
{
	int base[] = { 0, 3, 555555, 2, 7, 6, 8 };
	
	
	my_qsort(base, sizeof(base)/sizeof(base[0]), sizeof(int), compar);
	
	for (int i = 0; i < sizeof(base) / sizeof(base[0]); i++)
	{
		printf("%d ", base[i]);
	}

}
